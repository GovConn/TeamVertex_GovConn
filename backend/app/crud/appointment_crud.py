from sqlalchemy.orm import Session
from sqlalchemy import func
from datetime import datetime, timedelta
from app.models import reservation_services_model, notification_model
from app.schemas import reservation_schema
from fastapi import HTTPException
from app.schemas.reservation_schema import ReservationSlotSchema, ReservationSlotSchemaCreate, ReservedUser, ReservedUserCreate, ReservationSlotUpdate, CitizenResponse

async def get_available_slots_by_date(reservation_id: int, reservation_date: str, db: Session) -> list[reservation_schema.ReservationSlotSchema]:
    """
    Get all available slots for a specific reservation date
    where available capacity > 0
    """
    
    try:
        slots = db.query(reservation_services_model.ReservationSlots).filter(
            reservation_services_model.ReservationSlots.reservation_id == reservation_id,
            reservation_services_model.ReservationSlots.booking_date == reservation_date
        ).all()

        if not slots:
            raise HTTPException(status_code=404, detail="No available slots found")

        return [reservation_schema.ReservationSlotSchema(
            slot_id=slot.slot_id,
            reservation_id=slot.reservation_id,
            start_time=slot.start_time,
            end_time=slot.end_time,
            max_capacity=slot.max_capacity,
            reserved_count=slot.reserved_count,
            status=slot.status,
            booking_date=slot.booking_date,
            recurrent_count=slot.recurrent_count
        ) for slot in slots]
    
    except HTTPException as error:
        raise error

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching available slots: {str(e)}")

async def get_available_slots(service_id: int, db: Session) -> list[reservation_schema.ReservationSlotSchema]:
    """
    Get all available slots for a specific service
    where available capacity > 0
    """
    
    try:
        slots = db.query(reservation_services_model.ReservationSlots).filter(reservation_services_model.ReservationSlots.reservation_id == service_id).all()
        if slots is None:
            raise HTTPException(status_code=404, detail="No slots found for this service")

        return [reservation_schema.ReservationSlotSchema(
            slot_id=slot.slot_id,
            reservation_id=slot.reservation_id,
            start_time=slot.start_time,
            end_time=slot.end_time,
            max_capacity=slot.max_capacity,
            reserved_count=slot.reserved_count,
            status=slot.status,
            booking_date=slot.booking_date,
            recurrent_count=slot.recurrent_count
        ) for slot in slots]
    
    except HTTPException as error:
        raise error

    except Exception as e:
        HTTPException(status_code=500, detail=f"Error fetching slots: {str(e)}")

async def create_slot(slot_data: reservation_schema.ReservationSlotSchemaCreate, db: Session) -> list[reservation_schema.ReservationSlotSchema]:
    """
    Create a new reservation slot and, if `recurrent_count` > 0, create the same slot
    for the next `recurrent_count` weeks (booking_date + 7 days, +14 days, ...).

    This uses a single transaction with `db.add_all` to be efficient on the DB side.
    Returns a list of created `ReservationSlotSchema` objects (one per inserted slot).
    """
    try:
        # Prepare all slot model instances (base slot + recurring weeks)
        slots_to_create = []
        # Ensure we treat recurrent_count as an int (0 means only base slot)
        recur = int(slot_data.recurrent_count) if slot_data.recurrent_count is not None else 0

        for week_index in range(recur + 1):
            booking_date_i = slot_data.booking_date + timedelta(weeks=week_index)
            slot_obj = reservation_services_model.ReservationSlots(
                reservation_id=slot_data.reservation_id,
                start_time=slot_data.start_time,
                end_time=slot_data.end_time,
                max_capacity=slot_data.max_capacity,
                reserved_count=slot_data.reserved_count,
                status=slot_data.status,
                booking_date=booking_date_i,
                recurrent_count=slot_data.recurrent_count
            )
            slots_to_create.append(slot_obj)

        # Bulk add and commit in a single transaction
        db.add_all(slots_to_create)
        db.commit()

        # Refresh to populate autogenerated fields (slot_id)
        for s in slots_to_create:
            db.refresh(s)

        # Convert to response schemas
        created = [reservation_schema.ReservationSlotSchema(
            slot_id=s.slot_id,
            reservation_id=s.reservation_id,
            start_time=s.start_time,
            end_time=s.end_time,
            max_capacity=s.max_capacity,
            reserved_count=s.reserved_count,
            status=s.status,
            booking_date=s.booking_date,
            recurrent_count=s.recurrent_count
        ) for s in slots_to_create]

        return created

    except Exception as e:
        # Rollback in case of error and surface as HTTPException
        try:
            db.rollback()
        except Exception:
            pass
        raise HTTPException(status_code=500, detail=f"Error creating slot(s): {str(e)}")



async def get_slot(slot_id: int, db: Session) -> ReservationSlotSchema:
    """
    Get a slot by slot_id
    """
    try:
        slot = db.query(reservation_services_model.ReservationSlots).filter_by(slot_id=slot_id).first()
        if not slot:
            raise HTTPException(status_code=404, detail="Slot not found")
        return ReservationSlotSchema(
            slot_id=slot.slot_id,
            reservation_id=slot.reservation_id,
            start_time=slot.start_time,
            end_time=slot.end_time,
            max_capacity=slot.max_capacity,
            reserved_count=slot.reserved_count,
            status=slot.status,
            booking_date=slot.booking_date,
            recurrent_count=slot.recurrent_count
        )
    
    except HTTPException as error:
        raise error

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching slot: {str(e)}")

async def update_slot(slot_id: int, slot_data: ReservationSlotUpdate, db: Session) -> ReservationSlotSchema:
    """
    Update a slot by slot_id
    """
    try:
        slot = db.query(reservation_services_model.ReservationSlots).filter_by(slot_id=slot_id).first()
        if not slot:
            raise HTTPException(status_code=404, detail="Slot not found")
        for field in ["start_time", "end_time", "max_capacity", "reserved_count", "status"]:
            if hasattr(slot_data, field):
                setattr(slot, field, getattr(slot_data, field))
        db.commit()
        db.refresh(slot)
        return ReservationSlotSchema(
            slot_id=slot.slot_id,
            reservation_id=slot.reservation_id,
            start_time=slot.start_time,
            end_time=slot.end_time,
            max_capacity=slot.max_capacity,
            reserved_count=slot.reserved_count,
            status=slot.status,
            booking_date=slot.booking_date,
            recurrent_count=slot.recurrent_count
        )

    except HTTPException as error:
        raise error

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error updating slot: {str(e)}")
    

async def modify_reserved_count(slot_id: int, action: str, db: Session):
    """
    Add or remove reserved_count for a slot
    """
    try:
        slot = db.query(reservation_services_model.ReservationSlots).filter_by(slot_id=slot_id).first()
        if not slot:
            raise HTTPException(status_code=404, detail="Slot not found")
        if action == "add":
            if slot.reserved_count < slot.max_capacity:
                slot.reserved_count += 1
            else:
                raise HTTPException(status_code=400, detail="Slot is already fully booked")
        elif action == "remove":
            if slot.reserved_count > 0:
                slot.reserved_count -= 1
            else:
                raise HTTPException(status_code=400, detail="Reserved count already zero")
        else:
            raise HTTPException(status_code=400, detail="Invalid action")
        db.commit()
        db.refresh(slot)
        return {"slot_id": slot.slot_id, "reserved_count": slot.reserved_count}

    except HTTPException as error:
        raise error

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error modifying reserved count: {str(e)}")
    
async def delete_slot(slot_id: int, db: Session):
    """
    Delete a slot by slot_id
    """
    try:
        slot = db.query(reservation_services_model.ReservationSlots).filter_by(slot_id=slot_id).first()
        if not slot:
            raise HTTPException(status_code=404, detail="Slot not found")
        db.delete(slot)
        db.commit()
        return {"detail": "Slot deleted successfully"}

    except HTTPException as error:
        raise error

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error deleting slot: {str(e)}")

# --- ReservedUser CRUD ---
async def get_reserved_user(reference_id: int, db: Session) -> ReservedUser:
    """
    Get a reserved user by reference_id
    """
    try:
        user = db.query(reservation_services_model.ReservedUser).filter_by(reference_id=reference_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="Reserved user not found")

        notification = notification_model.Notification(
            nic=user.citizen_nic,
            message="Your reservation has been retrieved successfully.",
            status="approved",
            created_at=datetime.now()
        )
        db.add(notification)
        db.commit()

        return ReservedUser(
            reference_id=user.reference_id,
            slot_id=user.slot_id,
            citizen_nic=user.citizen_nic,
            citizen=None # Optionally fetch and serialize citizen details
        )

    except HTTPException as error:
        raise error

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching reserved user: {str(e)}")

async def add_reserved_user(user_data: ReservedUserCreate, db: Session) -> ReservedUser:
    """
    Add a reserved user to a slot
    """
    try:
        slot = db.query(reservation_services_model.ReservationSlots).filter_by(slot_id=user_data.slot_id).first()
        if not slot:
            raise HTTPException(status_code=404, detail="Slot not found")
        new_user = reservation_services_model.ReservedUser(
            slot_id=user_data.slot_id,
            citizen_nic=user_data.citizen_nic
        )
        if slot.max_capacity <= slot.reserved_count:
            raise HTTPException(status_code=400, detail="Slot is already fully booked")
        
        slot.reserved_count += 1
        db.add(new_user)
        db.commit()
        db.refresh(new_user)

        citizen_obj = new_user.citizen
        document_links = []
        if citizen_obj and citizen_obj.document_links:
            # citizen_obj.document_links is JSON, so it's already a list of dicts
            document_links = citizen_obj.document_links

        notification = notification_model.Notification(
            nic=citizen_obj.nic,
            message="You have successfully reserved a slot.",
            status="approved",
            created_at=datetime.now()
        )
        db.add(notification)
        db.commit()

        return ReservedUser(
            reference_id=new_user.reference_id,
            slot_id=new_user.slot_id,
            citizen_nic=new_user.citizen_nic,
            citizen=CitizenResponse(
                id=citizen_obj.id if citizen_obj else None,
                nic=citizen_obj.nic if citizen_obj else None,
                first_name=citizen_obj.first_name if citizen_obj else None,
                last_name=citizen_obj.last_name if citizen_obj else None,
                email=citizen_obj.email if citizen_obj else None,
                phone=citizen_obj.phone if citizen_obj else None,
                role=citizen_obj.role if citizen_obj else None,
                document_links=document_links,
                active=citizen_obj.active if citizen_obj else None,
                created_at=citizen_obj.created_at if citizen_obj else None
            ) if citizen_obj else None
        )

    except HTTPException as error:
        raise error

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error adding reserved user: {str(e)}")

async def delete_reserved_user(reference_id: int, db: Session):
    """
    Delete a reserved user by reference_id
    """
    try:
        user = db.query(reservation_services_model.ReservedUser).filter_by(reference_id=reference_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="Reserved user not found")
        slot = db.query(reservation_services_model.ReservationSlots).filter_by(slot_id=user.slot_id).first()
        if slot and slot.reserved_count > 0:
            slot.reserved_count -= 1
        db.delete(user)
        db.commit()

        notification = notification_model.Notification(
            nic=user.citizen_nic,
            message="Your reservation has been deleted successfully.",
            status="approved",
            created_at=datetime.now()
        )
        db.add(notification)
        db.commit()

        return {"detail": "Reserved user deleted"}

    except HTTPException as error:
        raise error

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error deleting reserved user: {str(e)}")

async def get_reserved_slot_details(nic: str, db: Session) -> list[ReservationSlotSchema]:
    """
    Get reserved slot details for a user by NIC
    """
    try:
        # Fetch ReservedUser rows for the given NIC and extract slot_id integers
        reserved_users = db.query(reservation_services_model.ReservedUser).filter(
            reservation_services_model.ReservedUser.citizen_nic == nic
        ).all()

        slot_ids = [ru.slot_id for ru in reserved_users]

        if not slot_ids:
            return []

        reserved_slots = db.query(reservation_services_model.ReservationSlots).filter(
            reservation_services_model.ReservationSlots.slot_id.in_(slot_ids)
        ).all()

        return [ReservationSlotSchema(
            slot_id=slot.slot_id,
            reservation_id=slot.reservation_id,
            start_time=slot.start_time,
            end_time=slot.end_time,
            max_capacity=slot.max_capacity,
            reserved_count=slot.reserved_count,
            status=slot.status,
            booking_date=slot.booking_date,
            recurrent_count=slot.recurrent_count
        ) for slot in reserved_slots]

    except HTTPException as error:
        raise error

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching reserved slot details: {str(e)}")


async def get_reserved_users(slot_id: int, db: Session) -> list[ReservedUser]:
    """
    Get reserved users for a specific slot
    """
    try:
        users = db.query(reservation_services_model.ReservedUser).filter(
            reservation_services_model.ReservedUser.slot_id == slot_id
        ).all()

        if not users:
            raise HTTPException(status_code=404, detail="No reserved users found for this slot")

        return [ReservedUser(
            reference_id=user.reference_id,
            slot_id=user.slot_id,
            citizen_nic=user.citizen_nic,
            citizen=CitizenResponse(
                id=user.citizen.id if user.citizen else None,
                nic=user.citizen.nic if user.citizen else None,
                first_name=user.citizen.first_name if user.citizen else None,
                last_name=user.citizen.last_name if user.citizen else None,
                email=user.citizen.email if user.citizen else None,
                phone=user.citizen.phone if user.citizen else None,
                role=user.citizen.role if user.citizen else None,
                document_links=user.citizen.document_links if user.citizen and user.citizen.document_links else [],
                active=user.citizen.active if user.citizen else None,
                created_at=user.citizen.created_at if user.citizen else None
            )
        ) for user in users]

    except HTTPException as error:
        raise error

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching reserved users: {str(e)}")

async def delete_slot(slot_id: int, db: Session) -> dict:
    """
    Delete a reservation slot by ID
    """
    try:
        slot = db.query(reservation_services_model.ReservationSlots).filter_by(slot_id=slot_id).first()
        if not slot:
            raise HTTPException(status_code=404, detail="Reservation slot not found")

        db.delete(slot)
        db.commit()

        return {"detail": "Reservation slot deleted successfully"}

    except HTTPException as error:
        raise error

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error deleting reservation slot: {str(e)}")